
 function's statements may include function calls, 
known as hierarchical function calls or nested function calls. 
Code such as user_input = int(input()) consists of such a hierarchical function call, wherein the input()
function is called and evaluates to a value that is then passed as an argument to the int() function.



def function 

def calc_circle_area(circle_diameter):
    pi_val=3.1415
    
    circle_radius=circle_diameter / 2.0
    circle_area = pi_val * circle_radius * circle_radius
    return circle_area

def calc_pizza_calories(pizza_diameter):
    calories_per_square_inch=16.7
    total_calories =calc_circle_area(pizza_diameter)*calories_per_square_inch
    return total_calories

print (calc_pizza_calories(12.0))
print (calc_pizza_calories(14.0))


-___________________________________________________________________________________

calculating step and calories consuming 

def steps_to_feet(num_steps):
    feet_per_step = 3
    feet = num_steps * feet_per_step
    return feet

def steps_to_calories(num_steps):
    steps_per_minute = 70.0
    calories_per_minute_walking = 3.5

    minutes = num_steps / steps_per_minute
    calories = minutes * calories_per_minute_walking
    return calories

steps = int(input('Enter number of steps walked: '))

feet = steps_to_feet(steps)
print('Feet:', feet)

calories = steps_to_calories(steps)
print('Calories:', calories)



(here is the code without define function. )**********
feet_per_step = 3
steps_per_minute = 70.0
calories_per_minute_walking = 3.5

steps = int(input('Enter number of steps walked: '))

feet = steps * feet_per_step
print('Feet:', feet)

minutes = steps / steps_per_minute
calories = minutes * calories_per_minute_walking
print('Calories:', calories)

_______________________________________________________

*** calculate ebay price

def calc_ebay_fee(sell_price):
    """Returns the fees charged by ebay.com given the selling
    price of fixed-price books, movies, music, or video games.
    fee is $0.50 to list plus 13% of selling price up to $50.00,
    5% of amount from $50.01 to $1000.00, and 
    2% for amount $1000.01 or more."""

    p50 = 0.13  # for amount $50 and lower
    p50_to_1000 = 0.05  # for $50.01-$1000
    p1000 = 0.02  # for $1000.01 and higher
    fee = 0.50  # fee to list item

    if sell_price <= 50:
        fee  = fee + (sell_price*p50)
    elif sell_price <= 1000:
        fee = fee + (50*p50) + ((sell_price-50)*p50_to_1000)
    else:
        fee = fee + (50*p50) + ((1000-50)*p50_to_1000) \
                  + ((sell_price-1000)*p1000)

    return fee

selling_price = float(input('Enter item selling price (ex: 65.00): '))
print('eBay fee: $', calc_ebay_fee(selling_price))

___________________________________________________________________________

zyDE 5.7.1: User-defined functions make a program easier to understand.
The problem below uses the function get_numbers() to read a number of integers from the user. Three unfinished functions are defined, 
which should print only certain types of numbers that the user entered. Complete the unfinished functions, adding loops and branches where necessary.
Match the output with the below sample:


size = 5

def get_numbers(num):
    numbers = []
    user_input = input('Enter {} integers:\n'.format(num))

    i = 0
    for token in user_input.split():
        number = int(token)     # Convert string input into integer
        numbers.append(number)  # Add to numbers list

        print(i, number)
        i += 1

    return numbers

def print_all_numbers(numbers):
    # Print numbers
    print('Numbers:')

def print_odd_numbers(numbers):
    # Print all odd numbers
    print('Odd numbers:')

def print_negative_numbers(numbers):
    # Print all negative numbers
    print('Negative numbers:')

nums = get_numbers(size)
print_all_numbers(nums)
print_odd_numbers(nums)
print_negative_numbers(nums)



_________________________________________________________________________________________


''' Your solution goes here '''

def print_popcorn_time(bag_ounces):
    if bag_ounces < 3:
        print("Too small")
    elif bag_ounces > 10:
        print("Too large")
    else:
        time = 6 * bag_ounces
        print(f"{time} seconds")

user_ounces = int(input())
print_popcorn_time(user_ounces)


___________________________________________________________________

def shampoo_instructions(num_cycles):
    if num_cycles < 1:
        print("Too few.")
    elif num_cycles > 4:
        print("Too many.")
    else:
        for i in range(1, num_cycles + 1):
            print(f"{i} : Lather and rinse.")
        print("Done.")

# Example usage in the main program
user_cycles = int(input())
shampoo_instructions(user_cycles)


__________________________________________________________________________________


def human_head():
    print('   ||||| ')
    print('   o   o')
    print('     >' )
    print('   ooooo')
    return

def monkey_head():
    print('   .-"-.')
    print(' _/.-.-.\\_')
    print('( ( o o ) )')
    print(' |/  "  \\|')
    print('  \\ .-. /')
    print('  /`"""`\\')
    return

def print_figure(face):
    face()  # Print the face
    print('     |')
    print('   --|--')
    print('  /  |  \\')
    print('@    |    @')
    print('     |')
    print('    /|\\')
    print('   @   @')
    return

choice = int(input('Enter "1" to draw monkey, "2" for human: '))

if choice == 1:
    print_figure(monkey_head)
elif choice == 2:
    print_figure(human_head)

__________________________________________________________________

(Variable and function scope
A variable or function object is only visible to part of a program,
known as the object's scope. When a variable is created inside a function, 
the variable's scope is limited to inside that function. 
In fact, because a variable's name does not exist until bound to an object, the variable's scope is actually limited to after the first assignment of the variable until the end of the function. 
The following program highlights the scope of variable total_inches.)


centimeters_per_inch = 2.54
inches_per_foot = 12

def height_US_to_centimeters(feet, inches):
    """ Converts a height in feet/inches to centimeters."""
    total_inches = (feet * inches_per_foot) + inches  # Total inches
    centimeters = total_inches * centimeters_per_inch
    return centimeters

feet = int(input('Enter feet: '))
inches = int(input('Enter inches: '))

print('Centimeters:', height_US_to_centimeters(feet, inches))


___________________________________________________________________________________




By default, a few names already exist in the global namespace – those names have been omitted in the output for brevity. Notice that my_var and my_func are added into the namespace once assigned.

Scope and scope resolution
Scope is the area of code where a name is visible. Namespaces are used to make scope work. Each scope, such as global scope or a local function scope, has its own namespace. If a namespace contains a name at a specific location in the code, then that name is visible and a programmer can use it in an expression.

There are at least three nested scopes that are active at any point in a program's execution: 1

Built-in scope – Contains all of the built-in names of Python, such as int(), str(), list(), range(), etc.
Global scope – Contains all globally defined names outside of any functions.
Local scope – Usually refers to scope within the currently executing function, but is the same as global scope if no function is executing.
When a name is referenced in code, the local scope's namespace is the first checked, followed by the global scope, and finally the built-in scope. If the name cannot be found in any namespace, the interpreter generates a NameError. The process of searching for a name in the available namespaces is called scope resolution.


aily_cals = 2300  # Daily calories
soda_cals = 200

def drink_soda(cals_left):
    return cals_left - soda_cals

daily_cals = drink_soda(daily_cals)
def avg(a, b):
2	    tmp = (a + b) / 2.0  # Creates tmp in local namespace
3	    return tmp
4	
5	a = 5
6	b = 10
7	tmp = a + b  # Creates tmp in global namespace
8	
9	print('Avg: {:f}'.format(avg(a, b))) 
10	print('Sum: {:f}'.format(tmp))



___________________________________________________________________________________


zyDE 5.12.1: List argument modification.
Address the FIXME comments. Move the respective code from the while-loop to the created function. The add_grade function has already been created.

Note: split() and strip() are string methods further explained elsewhere. split() separates a string into tokens using any whitespace as the default separator. The tokens are returned in a list (i.e., 'a b c'.split() returns ['a', 'b', 'c']). strip() returns a copy of a string with leading and trailing whitespace removed.


def add_grade(student_grades):
    print('Entering grade. \n')
    name, grade = input(grade_prompt).split()
    student_grades[name] = grade

# FIXME: Create delete_name function

# FIXME: Create print_grades function

student_grades = {}  # Create an empty dict
grade_prompt = "Enter name and grade (Ex. 'Bob A+'):\n"
delete_prompt = "Enter name to delete:\n"
menu_prompt = ("1. Add/modify student grade\n"
                "2. Delete student grade\n"
                "3. Print student grades\n"
                "4. Quit\n\n")

command = input(menu_prompt).lower().strip()

while command != '4':  # Exit when user enters '4'
    if command == '1':
        add_grade(student_grades)
    elif command == '2':
        # FIXME: Only call delete_name() here
        print('Deleting grade.\n')
        name = input(delete_prompt)
        del student_grades[name]
    elif command == '3':
        # FIXME: Only call print_grades() here
        print('Printing grades.\n')
        for name, grade in student_grades.items():
            print(name, 'has a', grade)
    else:
        print('Unrecognized command.\n')

    command = input().lower().strip()

___________________________________________________________________________________


Default parameter values
Sometimes a function has parameters that are optional. A function can have a default parameter value for one or more parameters, meaning that a function call can optionally omit an argument, and the default parameter value will be substituted for the corresponding omitted argument.

The following function prints a date in a particular style, given parameters for day, month, and year. The fourth parameter indicates the desired style, with 0 meaning American style, and 1 meaning European style. For July 30, 2012, the American style is 7/30/2012 and the European style is 30/7/2012.

def print_date(day, month, year, style=0):
    if style == 0:  # American
        print(month, '/', day, '/', year)
    elif style == 1:  # European
        print(day, '/', month, '/', year)
    else:
        print('Invalid Style')

print_date(30, 7, 2012, 0)
print_date(30, 7, 2012, 1)
print_date(30, 7, 2012)  # style argument not provided! Default value of 0 used


___________________________________________________________________________________
The fourth (and last) parameter is defined with a default value: style=0. If the function call does not provide a fourth argument, then style has value 0. A parameter's default value is the value used in the absence of an argument in the function call.

The same can be done for other parameters, as in: def print_date(day=1, month=1, year=2000, style=0). If positional arguments are passed (i.e., not keyword-arguments), then only the last arguments can be omitted. The following are valid calls to this print_date() function:


print_date(30, 7, 2012, 0)   # Defaults: none
print_date(30, 7, 2012)      # Defaults:                            style=0
print_date(30, 7)            # Defaults:                 year=2000, style=0
print_date(30)               # Defaults:        month=1, year=2000, style=0
print_date()                 # Defaults: day=1, month=1, year=2000, style=0



If a parameter does not have a default value, then failing to provide an argument (either keyword or positional) generates an error.

A common error is to provide a mutable object, like a list, as a default parameter. Such a definition can be problematic because the default argument object is created only once, at the time the function is defined (when the script is loaded), and not every time the function is called. Modification of the default parameter object will persist across function calls, which is likely not what a programmer intended. The below program demonstrates the problem with mutable default objects and illustrates a solution that creates a new empty list each time the function is called.

Default object modification
def append_to_list(value, my_list=[]):
    my_list.append(value)
    return my_list

numbers = append_to_list(50)  # default list appended with 50
print(numbers)
numbers = append_to_list(100)  # default list appended with 100
print(numbers)


Solution: Make new list
def append_to_list(value, my_list=None):  # Use default parameter value of None
    if my_list == None:  # Create a new list if a list was not provided
        my_list = []

    my_list.append(value)
    return my_list

numbers = append_to_list(50)  # default list appended with 50
print(numbers)
numbers = append_to_list(100)  # default list appended with 100
print(numbers)


The left program shows a function append_to_list() that has an empty list as default value of my_list. A programmer might expect that each time the function is called without specifying my_list, a new empty list will be created and the result of the function will be [value]. However, the default object persists across function calls. The solution replaces the default list with None, checking for that value, and then creating a new empty list in the local scope if necessary.


___________________________________________________________________________________

Mixing keyword arguments and default parameter values
Mixing keyword arguments and default parameter values allows a programmer to omit arbitrary arguments from a function call. Because keyword arguments use names instead of position to match arguments to parameters, any argument can be omitted as long as that argument has a default value.

Consider the print_date function from above. If every parameter has a default value, then the user can use keyword arguments to pass specific arguments anywhere in the argument list. Below are some sample function calls:


def print_date(day=1, month=1, year=2000, style=0):
    # ...


print_date(day=30, year=2012)   # Defaults:        month=1,            style=0
print_date(style=1)             # Defaults: day=1, month=1, year=2000
print_date(year=2012, month=4)  # Defaults: day=1,                     style=0








