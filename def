
 function's statements may include function calls, 
known as hierarchical function calls or nested function calls. 
Code such as user_input = int(input()) consists of such a hierarchical function call, wherein the input()
function is called and evaluates to a value that is then passed as an argument to the int() function.



def function 

def calc_circle_area(circle_diameter):
    pi_val=3.1415
    
    circle_radius=circle_diameter / 2.0
    circle_area = pi_val * circle_radius * circle_radius
    return circle_area

def calc_pizza_calories(pizza_diameter):
    calories_per_square_inch=16.7
    total_calories =calc_circle_area(pizza_diameter)*calories_per_square_inch
    return total_calories

print (calc_pizza_calories(12.0))
print (calc_pizza_calories(14.0))


-___________________________________________________________________________________

calculating step and calories consuming 

def steps_to_feet(num_steps):
    feet_per_step = 3
    feet = num_steps * feet_per_step
    return feet

def steps_to_calories(num_steps):
    steps_per_minute = 70.0
    calories_per_minute_walking = 3.5

    minutes = num_steps / steps_per_minute
    calories = minutes * calories_per_minute_walking
    return calories

steps = int(input('Enter number of steps walked: '))

feet = steps_to_feet(steps)
print('Feet:', feet)

calories = steps_to_calories(steps)
print('Calories:', calories)



(here is the code without define function. )**********
feet_per_step = 3
steps_per_minute = 70.0
calories_per_minute_walking = 3.5

steps = int(input('Enter number of steps walked: '))

feet = steps * feet_per_step
print('Feet:', feet)

minutes = steps / steps_per_minute
calories = minutes * calories_per_minute_walking
print('Calories:', calories)

_______________________________________________________

*** calculate ebay price

def calc_ebay_fee(sell_price):
    """Returns the fees charged by ebay.com given the selling
    price of fixed-price books, movies, music, or video games.
    fee is $0.50 to list plus 13% of selling price up to $50.00,
    5% of amount from $50.01 to $1000.00, and 
    2% for amount $1000.01 or more."""

    p50 = 0.13  # for amount $50 and lower
    p50_to_1000 = 0.05  # for $50.01-$1000
    p1000 = 0.02  # for $1000.01 and higher
    fee = 0.50  # fee to list item

    if sell_price <= 50:
        fee  = fee + (sell_price*p50)
    elif sell_price <= 1000:
        fee = fee + (50*p50) + ((sell_price-50)*p50_to_1000)
    else:
        fee = fee + (50*p50) + ((1000-50)*p50_to_1000) \
                  + ((sell_price-1000)*p1000)

    return fee

selling_price = float(input('Enter item selling price (ex: 65.00): '))
print('eBay fee: $', calc_ebay_fee(selling_price))

___________________________________________________________________________

zyDE 5.7.1: User-defined functions make a program easier to understand.
The problem below uses the function get_numbers() to read a number of integers from the user. Three unfinished functions are defined, 
which should print only certain types of numbers that the user entered. Complete the unfinished functions, adding loops and branches where necessary.
Match the output with the below sample:


size = 5

def get_numbers(num):
    numbers = []
    user_input = input('Enter {} integers:\n'.format(num))

    i = 0
    for token in user_input.split():
        number = int(token)     # Convert string input into integer
        numbers.append(number)  # Add to numbers list

        print(i, number)
        i += 1

    return numbers

def print_all_numbers(numbers):
    # Print numbers
    print('Numbers:')

def print_odd_numbers(numbers):
    # Print all odd numbers
    print('Odd numbers:')

def print_negative_numbers(numbers):
    # Print all negative numbers
    print('Negative numbers:')

nums = get_numbers(size)
print_all_numbers(nums)
print_odd_numbers(nums)
print_negative_numbers(nums)



_________________________________________________________________________________________


''' Your solution goes here '''

def print_popcorn_time(bag_ounces):
    if bag_ounces < 3:
        print("Too small")
    elif bag_ounces > 10:
        print("Too large")
    else:
        time = 6 * bag_ounces
        print(f"{time} seconds")

user_ounces = int(input())
print_popcorn_time(user_ounces)


___________________________________________________________________

def shampoo_instructions(num_cycles):
    if num_cycles < 1:
        print("Too few.")
    elif num_cycles > 4:
        print("Too many.")
    else:
        for i in range(1, num_cycles + 1):
            print(f"{i} : Lather and rinse.")
        print("Done.")

# Example usage in the main program
user_cycles = int(input())
shampoo_instructions(user_cycles)


__________________________________________________________________________________


def human_head():
    print('   ||||| ')
    print('   o   o')
    print('     >' )
    print('   ooooo')
    return

def monkey_head():
    print('   .-"-.')
    print(' _/.-.-.\\_')
    print('( ( o o ) )')
    print(' |/  "  \\|')
    print('  \\ .-. /')
    print('  /`"""`\\')
    return

def print_figure(face):
    face()  # Print the face
    print('     |')
    print('   --|--')
    print('  /  |  \\')
    print('@    |    @')
    print('     |')
    print('    /|\\')
    print('   @   @')
    return

choice = int(input('Enter "1" to draw monkey, "2" for human: '))

if choice == 1:
    print_figure(monkey_head)
elif choice == 2:
    print_figure(human_head)

__________________________________________________________________

(Variable and function scope
A variable or function object is only visible to part of a program,
known as the object's scope. When a variable is created inside a function, 
the variable's scope is limited to inside that function. 
In fact, because a variable's name does not exist until bound to an object, the variable's scope is actually limited to after the first assignment of the variable until the end of the function. 
The following program highlights the scope of variable total_inches.)


centimeters_per_inch = 2.54
inches_per_foot = 12

def height_US_to_centimeters(feet, inches):
    """ Converts a height in feet/inches to centimeters."""
    total_inches = (feet * inches_per_foot) + inches  # Total inches
    centimeters = total_inches * centimeters_per_inch
    return centimeters

feet = int(input('Enter feet: '))
inches = int(input('Enter inches: '))

print('Centimeters:', height_US_to_centimeters(feet, inches))


___________________________________________________________________________________




By default, a few names already exist in the global namespace – those names have been omitted in the output for brevity. Notice that my_var and my_func are added into the namespace once assigned.

Scope and scope resolution
Scope is the area of code where a name is visible. Namespaces are used to make scope work. Each scope, such as global scope or a local function scope, has its own namespace. If a namespace contains a name at a specific location in the code, then that name is visible and a programmer can use it in an expression.

There are at least three nested scopes that are active at any point in a program's execution: 1

Built-in scope – Contains all of the built-in names of Python, such as int(), str(), list(), range(), etc.
Global scope – Contains all globally defined names outside of any functions.
Local scope – Usually refers to scope within the currently executing function, but is the same as global scope if no function is executing.
When a name is referenced in code, the local scope's namespace is the first checked, followed by the global scope, and finally the built-in scope. If the name cannot be found in any namespace, the interpreter generates a NameError. The process of searching for a name in the available namespaces is called scope resolution.


aily_cals = 2300  # Daily calories
soda_cals = 200

def drink_soda(cals_left):
    return cals_left - soda_cals

daily_cals = drink_soda(daily_cals)
def avg(a, b):
2	    tmp = (a + b) / 2.0  # Creates tmp in local namespace
3	    return tmp
4	
5	a = 5
6	b = 10
7	tmp = a + b  # Creates tmp in global namespace
8	
9	print('Avg: {:f}'.format(avg(a, b))) 
10	print('Sum: {:f}'.format(tmp))



___________________________________________________________________________________


zyDE 5.12.1: List argument modification.
Address the FIXME comments. Move the respective code from the while-loop to the created function. The add_grade function has already been created.

Note: split() and strip() are string methods further explained elsewhere. split() separates a string into tokens using any whitespace as the default separator. The tokens are returned in a list (i.e., 'a b c'.split() returns ['a', 'b', 'c']). strip() returns a copy of a string with leading and trailing whitespace removed.


def add_grade(student_grades):
    print('Entering grade. \n')
    name, grade = input(grade_prompt).split()
    student_grades[name] = grade

# FIXME: Create delete_name function

# FIXME: Create print_grades function

student_grades = {}  # Create an empty dict
grade_prompt = "Enter name and grade (Ex. 'Bob A+'):\n"
delete_prompt = "Enter name to delete:\n"
menu_prompt = ("1. Add/modify student grade\n"
                "2. Delete student grade\n"
                "3. Print student grades\n"
                "4. Quit\n\n")

command = input(menu_prompt).lower().strip()

while command != '4':  # Exit when user enters '4'
    if command == '1':
        add_grade(student_grades)
    elif command == '2':
        # FIXME: Only call delete_name() here
        print('Deleting grade.\n')
        name = input(delete_prompt)
        del student_grades[name]
    elif command == '3':
        # FIXME: Only call print_grades() here
        print('Printing grades.\n')
        for name, grade in student_grades.items():
            print(name, 'has a', grade)
    else:
        print('Unrecognized command.\n')

    command = input().lower().strip()

___________________________________________________________________________________




